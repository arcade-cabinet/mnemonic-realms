# CLAUDE.md

## What This Is

Mnemonic Realms is a single-player 16-bit JRPG about memory as creative vitality. The gorgeous pixel art is always visible, always beautiful. Vibrancy manifests as spatial fog-of-war: forgotten areas are dark, partially remembered areas glow through colored haze, and fully remembered areas are crystal clear. Quest progression unlocks the world visually — replacing traditional RPG area-gates with a memory-aligned metaphor.

**Engine**: MnemonicEngine — Expo (React Native) + React Native Skia + Koota ECS. Web-first via Expo web, with iOS/Android architecture ready.

**RPG-JS has been archived** to `docs/rpgjs-archive/`. Do not modify archived files. They are preserved as reference context.

## Commands

```bash
pnpm install          # Install dependencies
pnpm expo start --web # Expo dev server (web)
pnpm build:web        # Production build (expo export --platform web -> dist/)
pnpm lint             # Biome check (engine/, app/, ui/, gen/)
pnpm lint:fix         # Biome auto-fix
pnpm test             # Playwright E2E tests
pnpm test:unit        # Vitest unit tests

# Runtime Content Generation
pnpm generate:content   # Generate all runtime JSON (maps + encounters)
pnpm validate:runtime   # Validate generated runtime data

# Assemblage System (gen/ pipeline — still active)
pnpm assemblage compile-world            # Compile docs/world/ hierarchy -> DDL + maps
pnpm assemblage emit-runtime [id|all]    # Generate runtime JSON for new engine
pnpm assemblage build-region [id|all]    # Build region outdoor maps from DDL
pnpm assemblage preview [mapId]          # ASCII rendering
pnpm assemblage validate [mapId]         # Check overlaps, gaps, missing hooks
pnpm assemblage parse [act1|act2|act3|all] # Markdown act scripts -> scene DDL
pnpm assemblage compile [mapId|all]      # Scene DDL -> MapComposition
pnpm assemblage scenes [mapId]           # List scenes per map

# GenAI Pipeline
pnpm gen build [tilesets|sprites|portraits|items|code|all]
pnpm gen generate [images|code|all] [--dry-run] [--force] [--model <id>]
pnpm gen status
```

---

## CRITICAL RULES -- DO NOT VIOLATE

1. **RPG-JS is archived.** All RPG-JS code lives in `docs/rpgjs-archive/`. Never modify it. Never reference it from active code. It exists as context only.

2. **16x16 pixel tiles everywhere.** All premium tilesets. Maps sized accordingly (60x60 = 960px).

3. **The gorgeous art is ALWAYS visible.** Vibrancy is spatial fog-of-war (forgotten=dark, partial=haze, remembered=clear), NOT desaturation or color tinting. Player's active area is never degraded. Don't use visual props to tell the story — tell it through narrative, dialogue, and world events.

4. **Story drives everything.** Think Hobbit, not acts/scenes. Bag End is intimate but the world is immediately vast. Open world, open map, transitions to other worlds.

5. **Never hand-edit generated output.** The assemblage system generates maps. Runtime JSON is generated by `emit-runtime`. Edit the source (DDL, assemblages, docs/world/), not the output.

6. **Build automation, not artifacts.** When the next step requires manual repetition, STOP. Build the tool.

7. **You are the creative director.** If something reads like a placeholder, fix it. No confirmation needed.

8. **Logic in subpackages, not TSX.** TSX files contain ONLY rendering markup + hooks. Business logic lives in `engine/` subpackages.

9. **Encounters are a World.** Combat and special moments transition to the encounters world — same onion hierarchy as shops, dungeons, overworld.

---

## PRD + Ralph TUI Execution

The full PRD lives at `tasks/prd-mnemonic-engine.md` (26 user stories). The Ralph JSON lives at `tasks/prd.json`, ready for:

```bash
ralph-tui run --prd tasks/prd.json
```

Ralph creates independent worktrees off `main` for parallel story execution. Stories with no blocking dependencies can run simultaneously.

---

## Detailed Documentation

| Topic | File | What's In It |
|-------|------|-------------|
| **MnemonicEngine design** | [docs/plans/2026-02-19-mnemonic-engine-design.md](docs/plans/2026-02-19-mnemonic-engine-design.md) | Full architecture: Expo + Skia + Koota ECS |
| **Implementation plan** | [docs/plans/2026-02-19-mnemonic-engine-implementation.md](docs/plans/2026-02-19-mnemonic-engine-implementation.md) | 15-task TDD plan |
| **PRD** | [tasks/prd-mnemonic-engine.md](tasks/prd-mnemonic-engine.md) | 26 user stories with acceptance criteria |
| World architecture | [docs/design/world-architecture.md](docs/design/world-architecture.md) | Fractal world algebra, pacing, connective tissue |
| Creative direction | [docs/design/creative-direction.md](docs/design/creative-direction.md) | The mandate, naming conventions, decisions log |
| Assemblage system | [docs/design/assemblage-system.md](docs/design/assemblage-system.md) | Full architecture, tileset strategy, palettes |
| Narrative architecture | [docs/design/narrative-architecture.md](docs/design/narrative-architecture.md) | DDL pipeline, scene->map relationship |
| Story bible | `docs/story/` | Act scripts, characters, dialogue-bank |
| World geography | `docs/world/` | Region + location hierarchy (DDL source of truth) |
| RPG-JS archive | `docs/rpgjs-archive/` | All legacy RPG-JS code and config (read-only reference) |

---

## Core Concepts

### Worlds All The Way Down

Everything is a **world**. A shop is a world. A dungeon is a world. The outdoor map is a world. Combat encounters are a world. Everything composes fractally: World -> Regions -> Anchors -> World Slots -> Child Worlds.

**Full details**: [docs/design/world-architecture.md](docs/design/world-architecture.md)

### Encounters World

Combat and special moments are NOT modal overlays. They are a **world** in the onion hierarchy:

- **Regions** = encounter classes (e.g., `settled-lands-wildlife`, `frontier-elementals`)
- **Locations** = specific encounters within a class (e.g., `wolf-pack`, `slime-swarm`)
- Default layout: Final Fantasy / Chrono Trigger split-screen (enemies top, commands bottom)
- Encounters chain: combat -> dialogue -> surprise -> combat
- DDL-driven: `gen/ddl/encounters/` with Zod validation
- Random encounter pools specified per overworld region

### Vibrancy as Spatial Fog-of-War

Instead of traditional RPG area-gating (invisible walls, story triggers), areas are gated by **memory state**:

| Area State | Visual | Gameplay |
|-----------|--------|----------|
| **Forgotten** | Opaque darkness | Player can enter a few paces, then warned + damage until they leave |
| **Partial** | Colored haze (invitation) | Player knows it's time to explore here |
| **Remembered** | Crystal clear, full gorgeous art | Fully accessible, no visual filter |

Quest progression drives state transitions. Per-area, not global. Player's active area is **always** beautiful.

### Koota ECS

Data-oriented ECS with SoA (struct-of-arrays) storage. Chosen for:
- Deterministic iteration order (renders maps from instruction sets predictably)
- Cache-friendly trait access patterns
- From pmndrs ecosystem (same team as Miniplex, Three.js ecosystem)

---

## Architecture (Quick Reference)

### Engine (`engine/`)

Koota ECS + pure systems + Skia renderers.

- `engine/ecs/traits.ts` — 19 ECS traits (Position, Velocity, Sprite, Collision, NpcAi, Vibrancy, etc.)
- `engine/ecs/world.ts` — `createGameWorld()` factory with Koota world
- `engine/ecs/queries.ts` — 15+ cached queries for system iteration
- `engine/ecs/systems/` — Pure functions: movement, collision, camera, interaction, npc-ai, vibrancy, particles
- `engine/renderer/tile-renderer.tsx` — Skia Atlas GPU tile rendering
- `engine/renderer/sprite-renderer.tsx` — Skia Atlas sprite rendering
- `engine/renderer/particle-renderer.tsx` — Skia particle effects
- `engine/renderer/camera.tsx` — Camera tracking + viewport culling
- `engine/renderer/shader/` — Fog-of-war shader (vibrancy spatial effect)
- `engine/world/loader.ts` — Runtime map JSON loader
- `engine/world/spawner.ts` — Entity spawner (NPCs, objects, triggers)
- `engine/world/transition.ts` — World transition state machine
- `engine/encounters/types.ts` — Encounter, enemy, combat action types
- `engine/encounters/combat-engine.ts` — Turn-based combat (pure functions)
- `engine/encounters/chain.ts` — Encounter chain executor (combat → dialogue → surprise → combat)
- `engine/audio/music.ts` — BGM state machine with crossfade
- `engine/audio/sfx.ts` — SFX registry and playback
- `engine/audio/vibrancy-filter.ts` — BiquadFilterNode low-pass sweep (2000Hz muffled → 20000Hz vivid)
- `engine/save/quest-tracker.ts` — Quest state management
- `engine/save/serializer.ts` — Save/load serialization
- `engine/save/storage.ts` — AsyncStorage/localStorage adapter
- `engine/inventory/inventory.ts` — Item management and equipment slots
- `engine/inventory/shop.ts` — Buy/sell transaction logic
- `engine/input.ts` — Platform-agnostic input (keyboard + touch, action/cancel keys)
- `engine/game-loop.ts` — 60fps via Reanimated `useFrameCallback`

### App (`app/`)

Expo Router pages.

- `app/_layout.tsx` — Root layout with providers
- `app/index.tsx` — Title screen route
- `app/game.tsx` — Game canvas route

### UI (`ui/`)

React Native components (NOT Skia) overlaying the game canvas.

- `ui/dialogue-box.tsx` — Typewriter text, portraits, choices
- `ui/combat-ui.tsx` — Split-screen encounter UI (enemies top, commands bottom)
- `ui/hud/` — HUD components: HP bar, vibrancy meter, zone placard
- `ui/inventory-screen.tsx` — Parchment grid, equipment slots
- `ui/shop-screen.tsx` — Buy/sell with keeper personality
- `ui/quest-log.tsx` — Callum's journal style
- `ui/title-screen/` — Logo animation, menu, class selection
- `ui/touch-controls.tsx` — Virtual d-pad + action buttons
- `ui/touch-intent.ts` — Touch input intent mapping
- `ui/hooks/` — Shared UI hooks (e.g., `use-typewriter.ts`)
- `ui/theme/` — Gluestack UI theme with warm amber tokens

### GenAI Pipeline (`gen/`)

- `gen/assemblage/` — Composable map building system
- `gen/assemblage/pipeline/runtime-serializer.ts` — Map JSON serializer
- `gen/assemblage/pipeline/encounter-serializer.ts` — Encounter JSON serializer
- `gen/assemblage/pipeline/` — Canvas, TMX serializer, event codegen, region renderer
- `gen/assemblage/compiler/` — Markdown world compiler, scene compiler
- `gen/assemblage/catalog/` — Markdown assemblage definitions (atoms → molecules → organisms)
- `gen/ddl/` — Data Definition Layer (scenes, maps, encounters, enemies, items, skills, quests, regions, etc.)
- `gen/schemas/` — Zod schemas for all DDL types (including `ddl-encounters.ts`, `ddl-enemies.ts`, `ddl-items.ts`, `ddl-skills.ts`, `ddl-quests.ts`)
- `gen/manifests/` — Generation status tracking

### Scripts (`scripts/`)

- `scripts/generate-runtime-content.ts` — Generates all runtime JSON (maps + encounters)
- `scripts/validate-runtime-content.ts` — Validates generated runtime data against schemas
- `scripts/validation/` — Comprehensive validation suite (maps, sprites, content, events, NPCs, dungeons, puzzles)

### Data (`data/`)

Runtime JSON output consumed by the engine at load time. Generated by `pnpm generate:content`.

- `data/maps/` — Runtime map JSON
- `data/encounters/` — Runtime encounter JSON

### Bible Docs (`docs/`)

- `docs/story/` — **Primary driver.** Act scripts, characters, dialogue-bank
- `docs/world/` — Region + location hierarchy (compilable DDL source of truth)
- `docs/design/` — Architecture, visual direction, systems design
- `docs/plans/` — Design docs and implementation plans
- `docs/rpgjs-archive/` — Archived RPG-JS code (read-only reference)

### Key Patterns

- **Expo + Skia + Koota**: React Native for cross-platform, Skia Atlas for GPU tile rendering, Koota ECS for deterministic game state
- **Worlds all the way down**: Everything is a world. Shops, dungeons, encounters, overworld.
- **Assemblage composition**: Maps built from reusable markdown-defined pieces
- **DDL-driven everything**: Maps, encounters, quests, dialogue — all Zod-validated JSON from DDL
- **Runtime JSON**: Engine loads `data/maps/*.json` directly. No TMX at runtime.
- **Fog-of-war vibrancy**: Per-area spatial effect, not global shader. Quest-driven.
- **Audio vibrancy**: BiquadFilterNode low-pass sweep (2000Hz muffled → 20000Hz vivid)
- **Encounter chaining**: Combat → dialogue → surprise → combat sequences via chain executor
- **Touch input**: Virtual d-pad + action buttons with intent mapping for mobile play

### Config Files

- `app.json` — Expo app config
- `biome.json` — Biome 2.3: 2-space indent, single quotes, semicolons, 100 char width
- `tsconfig.json` — TypeScript config (excludes `docs/rpgjs-archive/`)
- `metro.config.cjs` — Metro bundler (excludes `docs/rpgjs-archive/`)
- `tailwind.config.js` — NativeWind / Tailwind config
- `vitest.config.ts` — Vitest unit test config
- `playwright.config.ts` — Playwright E2E test config
- `package.json` — Expo + Skia + Koota + Reanimated deps

### CI

GitHub Actions: pnpm install -> lint -> test:unit -> build:web -> deploy `dist/` to GitHub Pages.
