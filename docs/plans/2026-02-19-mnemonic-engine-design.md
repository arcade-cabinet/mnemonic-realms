# MnemonicEngine Design: React Native Skia + ECS + Onion System

**Date**: 2026-02-19
**Status**: Design
**Decision**: Replace RPG-JS entirely with a custom engine built on Expo + React Native Skia + Miniplex ECS

---

## Why

RPG-JS forces:
- TMX compilation (baking a Ferrari into a Pinto)
- Discrete maps with `player.changeMap()` transitions (we want open world)
- Socket.io mock for single-player (dead weight)
- Vue GUI (ugly, inflexible, fails to translate the game's metaphors to player experience)
- 153 dead `@rpgjs/database` decorator files that do nothing
- A compiler patch to prevent it from fighting our project structure

Our gen/ pipeline already IS a game engine. It produces deterministic `MapComposition` and `MapCanvas` instruction sets. The only thing RPG-JS provides at runtime is tile rendering + collision + sprite movement + camera -- all replaceable.

**The vision**: The game should FEEL like memory awakening. Greyscale worlds blooming into color. Ambient motes of light drifting between sketched trees. Dialogue that feels authored, not generated. A world that breathes. RPG-JS cannot deliver this. Our onion system + Skia + ECS can.

---

## The Stack

| Layer | Technology | Purpose |
|-------|-----------|---------|
| **Platform** | Expo (React Native) | Cross-platform: web + iOS + Android |
| **Rendering** | @shopify/react-native-skia | GPU-accelerated 2D: tiles, sprites, particles, shaders |
| **ECS** | Miniplex 2.0 (or Koota) | Entity management: player, NPCs, items, triggers |
| **Animation** | React Native Reanimated 3 | UI thread game loop, shared values, worklets |
| **Input** | react-native-gesture-handler | Touch (mobile), keyboard (web), gamepad |
| **Audio** | expo-audio | BGM loops, SFX |
| **Routing** | expo-router | Title, game, overlays (inventory, shop, pause) |
| **UI** | React Native Reusables (shadcn for RN) + NativeWind + Moti | Beautiful game UI that translates the game's vision |
| **Data** | gen/ onion system | Markdown -> Assemblages -> Palettes -> Runtime JSON |

---

## Architecture

```
Expo App
|-- app/                              # expo-router screens
|   |-- _layout.tsx                   # Root: Skia loading, providers
|   |-- index.tsx                     # Title screen
|   |-- game.tsx                      # Main game (Skia canvas + HUD overlay)
|   |-- (overlays)/                   # Modal overlays (keep game mounted)
|       |-- inventory.tsx
|       |-- shop.tsx
|       |-- quest-log.tsx
|       |-- pause.tsx
|
|-- engine/                           # MnemonicEngine core
|   |-- ecs/
|   |   |-- world.ts                  # Miniplex world + entity type
|   |   |-- queries.ts                # Archetypal queries
|   |   |-- systems/                  # Pure functions called per tick
|   |       |-- movement.ts
|   |       |-- collision.ts
|   |       |-- camera.ts
|   |       |-- npc-ai.ts
|   |       |-- interaction.ts
|   |       |-- encounter.ts
|   |       |-- vibrancy.ts
|   |
|   |-- renderer/
|   |   |-- tile-renderer.tsx         # Skia Atlas for tile layers
|   |   |-- sprite-renderer.tsx       # Skia Atlas for entities
|   |   |-- particle-renderer.tsx     # Memory motes, vibrancy shimmer
|   |   |-- shader/
|   |   |   |-- vibrancy.sksl        # Greyscale <-> color per vibrancy uniform
|   |   |   |-- shimmer.sksl         # Ambient light shimmer effect
|   |   |   |-- transition.sksl      # Zone transition fade
|   |   |-- camera.tsx               # Skia Group transform for viewport
|   |
|   |-- world/
|   |   |-- loader.ts                # Load MapComposition JSON -> ECS entities
|   |   |-- streaming.ts             # Chunk manager: viewport culling
|   |   |-- transition.ts            # Zone transitions (seamless, not changeMap)
|   |
|   |-- game-loop.ts                 # useFrameCallback -> tick all systems
|   |-- input.ts                     # Keyboard + touch + gamepad -> shared values
|
|-- ui/                               # Game UI (React Native, NOT Skia)
|   |-- dialogue-box.tsx              # Character portrait + typewriter text
|   |-- hud.tsx                       # HP, vibrancy bar, zone name placard
|   |-- minimap.tsx                   # Collision grid overview
|   |-- combat-ui.tsx                 # Turn-based battle interface
|   |-- inventory-screen.tsx          # Grid with drag-drop items
|   |-- shop-screen.tsx               # Buy/sell interface
|   |-- quest-log.tsx                 # Active/completed quests
|   |-- title-screen.tsx              # Class selection, new/load game
|
|-- data/                             # Runtime game data (generated by gen/)
|   |-- maps/                         # MapComposition JSON per region
|   |-- palettes/                     # TilesetPalette JSON per biome
|   |-- scenes/                       # Scene DDL JSON per act
|   |-- dialogue/                     # Dialogue trees
|
|-- gen/                              # BUILD-TIME pipeline (unchanged)
    |-- (existing assemblage system)
    |-- NEW: emit-runtime command -> outputs JSON instead of TMX
```

---

## Data Flow: Onion System to Runtime

The key architectural decision: **the gen/ pipeline outputs JSON, not TMX**. Everything else stays the same.

```
BUILD TIME (gen/ pipeline, runs once):
  docs/world/{region}/{location}.md
    -> markdown compiler
    -> MapComposition (already exists as TypeScript object)
    -> NEW: JSON serializer (replaces TMX serializer)
    -> data/maps/{regionId}.json

RUNTIME (MnemonicEngine, runs in browser/app):
  data/maps/settled-lands.json
    -> world/loader.ts
    -> Populate Miniplex world with entities
    -> Tile data stays as typed arrays (NOT entities)
    -> NPCs, chests, stones, triggers = entities
    -> renderer/tile-renderer.tsx reads tile arrays
    -> renderer/sprite-renderer.tsx reads entity queries
    -> Skia Atlas draws everything
    -> camera.tsx applies viewport transform
    -> vibrancy.sksl shader tints the world
```

### What Changes in gen/

Only ONE new file: a JSON serializer that outputs the same `MapCanvas` data as JSON instead of TMX XML.

```typescript
// gen/assemblage/pipeline/runtime-serializer.ts
export function serializeToRuntime(canvas: MapCanvas, palette: TilesetPalette): RuntimeMapData {
  return {
    id: canvas.id,
    width: canvas.width,
    height: canvas.height,
    tileWidth: canvas.tileWidth,
    tileHeight: canvas.tileHeight,
    palette: palette.name,
    layers: Object.fromEntries(
      [...canvas.layers].map(([name, tiles]) => [name, resolveToGids(tiles, palette)])
    ),
    collision: Array.from(canvas.collision),
    objects: canvas.objects,
    visuals: canvas.visuals,
    hooks: canvas.hooks,
  };
}
```

### What Stays in gen/

Everything. The markdown compiler, assemblage parser, region composer, palette builder, TSX parser -- all unchanged. They already produce the right data structures. Only the last 50 lines of serialization change.

---

## Entity Component System

### Entity Type

```typescript
type Entity = {
  // Position (tile coordinates)
  position?: { x: number; y: number };

  // Rendering
  sprite?: { sheet: string; frame: number; width: number; height: number };
  layer?: 'ground' | 'object' | 'above';
  facing?: 'up' | 'down' | 'left' | 'right';

  // Tags
  player?: true;
  npc?: true;
  collidable?: true;
  interactable?: true;

  // Behavior
  velocity?: { x: number; y: number };
  dialogue?: { id: string; lines: string[]; portrait?: string };
  aiState?: 'idle' | 'patrol' | 'follow';
  patrolPath?: { x: number; y: number }[];

  // Game state
  health?: { current: number; max: number };
  inventory?: string[];
  questFlags?: Record<string, boolean>;
  vibrancy?: number;

  // Map objects
  chest?: { contents: string[]; opened: boolean };
  resonanceStone?: { fragmentId: string; discovered: boolean };
  transition?: { targetMap: string; targetTile: { x: number; y: number } };
  trigger?: { eventId: string; condition?: string };
};
```

### What Is an Entity vs What Is Data

| Thing | Entity? | Why |
|-------|---------|-----|
| Player | Yes | Has position, input, inventory, state |
| NPCs | Yes | Have position, AI, dialogue, interaction |
| Resonance stones | Yes | Have state (discovered/not), interaction |
| Treasure chests | Yes | Have state (opened/not), interaction |
| Map transitions | Yes | Have trigger behavior |
| Event triggers | Yes | Have conditional behavior |
| Ground tiles | **No** | Static data, Uint16Array, no behavior |
| Tree/wall tiles | **No** | Static collision grid, Uint8Array |
| Visual objects | **No** | Static decorations, drawn from arrays |

Tiles stay as typed arrays for performance. Only behavioral objects become entities. A typical map has 3,600 tiles but only 20-50 entities.

---

## Rendering Architecture

### Tile Layers (Skia Atlas)

Each tile layer is rendered as a single Skia `<Atlas>` draw call:

```tsx
<Atlas
  image={tilesetImage}
  sprites={visibleTileRects}      // SkRect[] -- sub-regions of spritesheet
  transforms={visibleTilePositions} // RSXform[] -- screen positions
  sampling={{ filter: FilterMode.Nearest, mipmap: MipmapMode.None }}
/>
```

- `FilterMode.Nearest` = pixel-perfect 16x16 tiles, no smoothing
- Viewport culling: only tiles within camera bounds go into the arrays
- Multiple layers stack: ground -> road -> water -> objects -> above
- Static layers can be pre-rendered to `SkPicture` for even better perf

### Entity Sprites (Skia Atlas)

A second Atlas for dynamic entities (player, NPCs), updated every frame:

```tsx
const entityTransforms = useRSXformBuffer(entityCount, (val, i) => {
  'worklet';
  const entity = renderableEntities[i];
  val.set(Skia.RSXform(scale, 0,
    entity.position.x * TILE_SIZE,
    entity.position.y * TILE_SIZE));
});
```

### Vibrancy Shader (SkSL)

The core visual mechanic -- the world transitions from greyscale (0 vibrancy) to full color (100 vibrancy):

```glsl
// shader/vibrancy.sksl
uniform shader image;
uniform float vibrancy; // 0.0 = muted grey, 1.0 = full vivid color

half4 main(float2 xy) {
  half4 col = image.eval(xy);
  float grey = dot(col.rgb, half3(0.299, 0.587, 0.114));
  half3 muted = mix(half3(grey), col.rgb, half(vibrancy));
  return half4(muted, col.a);
}
```

Applied as a `<RuntimeShader>` over the entire game canvas `<Group>`. The `vibrancy` uniform is a Reanimated shared value that updates smoothly.

### Camera System

```tsx
const cameraTransform = useDerivedValue(() => [{
  translateX: -cameraX.value * TILE_SIZE * scale,
  translateY: -cameraY.value * TILE_SIZE * scale,
}]);

<Canvas style={StyleSheet.absoluteFill}>
  <Group transform={cameraTransform}>
    <TileLayer layer="ground" />
    <TileLayer layer="road" />
    <TileLayer layer="water" />
    <EntityLayer />
    <TileLayer layer="above" />
    <ParticleLayer />
  </Group>
</Canvas>
```

### Particle Effects (Memory Motes)

Ambient particles that drift through the world, density proportional to vibrancy:

- Atlas-based: small sprite particles with per-frame position updates
- Each mote has: position, velocity, lifetime, alpha
- Density scales with `vibrancy` uniform
- At Vivid tier (90+): motes are bright, dense, leave trails
- At Muted tier (<30): sparse, dim, barely visible

---

## UI/UX Plan: Translating the Game's Vision

**The problem with RPG-JS GUI**: It looked like a developer wireframe. Generic text boxes. No personality. The game's core metaphor -- memory as creative vitality, a world blooming from grey to vivid -- was completely invisible in the UI.

**The solution**: React Native Reusables (shadcn for RN) + NativeWind + custom components that BREATHE the game's themes.

### Design Principles

1. **The UI is part of the world.** Dialogue boxes should feel like memory surfacing -- soft edges, warm glow, text that materializes. Not hard rectangles with instant text.

2. **Vibrancy affects everything.** At low vibrancy, the HUD is muted, edges are rough, fonts are sketchy. At high vibrancy, the HUD blooms with color, edges are crisp, fonts are clean. The UI IS the vibrancy system.

3. **Every interaction tells a story.** Opening inventory shows resonance fragments orbiting. The shop interface shows the keeper's personality. The quest log feels like Callum's journal, not a database.

4. **Animations are physics, not timing.** Spring-based animations (Reanimated/Moti) for everything. Nothing pops in. Everything settles naturally.

### Component Library: React Native Reusables

Using https://reactnativereusables.com/ as the foundation (shadcn for React Native):

- **Accordion** -- Quest log sections, dialogue history
- **Dialog/Modal** -- Confirmations, save prompts
- **Navigation Menu** -- Pause menu, settings
- **Input** -- Character naming, search
- **Progress** -- HP/SP bars, vibrancy meter
- **Tooltip** -- Item descriptions, stat comparisons

Built on top of Reusables with custom game theming:

### Key UI Components

**Dialogue Box**: Bottom panel. Character portrait (left, animated idle). Speaker name in accent color. Text materializes letter-by-letter with subtle opacity animation (not harsh typewriter). Background has frosted glass effect with a warm amber tint at high vibrancy, cool grey at low. Choice options slide in from right. Advance indicator pulses gently.

**HUD**: Minimal, top-of-screen. HP bar (red gradient). SP bar (blue gradient). Vibrancy meter (THE signature element -- a horizontal bar that transitions from grey pencil-sketch to golden radiance). Zone name placard on entry (drifts in from top, holds 3 seconds, dissolves). All elements fade to near-invisible during exploration, brighten during combat or key moments.

**Inventory**: Fullscreen overlay. Items displayed as illustrated icons on a parchment-style grid. Equipment slots shaped like the character silhouette. Resonance fragments displayed as orbiting colored gems. Drag-to-equip with spring animations. Item detail: name, description (written in-world, not stats-first), stats secondary.

**Combat UI**: Enemies appear at top with health bars. Player commands bottom-center. The resonance broadcast mechanic is THE key differentiator: a radial selector where you choose emotion (joy/sorrow/fury/calm/awe) + element (fire/water/earth/wind/light) + potency (1-5). The selection animates as colored energy building around the player. Cast triggers a full-screen flash in the broadcast's color.

**Title Screen**: The game logo dissolves from grey sketch to golden text as a vibrancy-like effect plays. "Mnemonic Realms" appears letter by letter with memory mote particles. Menu options: New Journey / Continue / Settings. Character class selection shows three class archetypes with idle animations and personality quotes.

**World Map (future)**: An illustrated parchment map of the remembered world. Discovered zones glow with their vibrancy level. Undiscovered zones are sketched outlines. Zoom and pan with gesture handler. Tap a zone to fast-travel (if conditions met).

### Layer Structure

```
<View style={{ flex: 1 }}>
  {/* Layer 1: Game canvas (Skia) */}
  <Canvas style={StyleSheet.absoluteFill} pointerEvents="box-none">
    {/* All tile/sprite/particle/shader rendering */}
  </Canvas>

  {/* Layer 2: Game HUD (React Native, always visible) */}
  <HUD pointerEvents="box-none" />

  {/* Layer 3: Dialogue (React Native, shown during conversations) */}
  {activeDialogue && <DialogueBox {...activeDialogue} />}

  {/* Layer 4: Overlays (via expo-router modal) */}
</View>
```

---

## Game Loop

```typescript
// engine/game-loop.ts
import { useFrameCallback } from 'react-native-reanimated';

export function useGameLoop() {
  return useFrameCallback((frameInfo) => {
    'worklet';
    const dt = frameInfo.timeSincePreviousFrame ?? 16;

    inputSystem(dt);        // Read input -> update player velocity
    movementSystem(dt);     // Move entities
    collisionSystem();      // Check collisions
    cameraSystem(dt);       // Update camera to follow player
    interactionSystem();    // Check player near NPC/chest/stone
    npcAISystem(dt);        // Patrol, idle animations
    encounterSystem();      // Random encounter step counter
    vibrancySystem(dt);     // Update vibrancy effects
    particleSystem(dt);     // Update particles
  });
}
```

All systems run on the UI thread via worklets. React re-renders only for:
- Entity spawn/despawn (map transitions)
- Dialogue start/end
- Menu open/close
- Quest flag changes

Normal gameplay runs at 60fps with zero React re-renders.

---

## Open World Streaming

Instead of RPG-JS discrete maps with `player.changeMap()`:

### Phase 1: Seamless Transitions

At any time, 1 location is fully loaded + adjacent edge tiles pre-loaded. When the player walks to a boundary:
1. Start loading adjacent location JSON
2. Cross-fade vibrancy shader
3. Swap tile data + spawn new entities
4. Zone name placard appears

No loading screens. No black frames. Camera pans smoothly while data swaps.

### Phase 2: True Open World (Future)

All locations stitched into one continuous 300x300+ tile world. Chunk manager handles viewport culling. Walk from Everwick to Ambergrove without any transition. Requires unified palettes and background chunk loading.

---

## What Gets Deleted

| Directory | Replacement |
|-----------|-------------|
| `main/` (entire RPG-JS module) | `engine/` + `app/` + `ui/` |
| `@rpgjs/*` packages (all 9) | Expo + Skia + Reanimated |
| `rpg.toml` | `app.json` (Expo) |
| `gen/.../tmx-serializer.ts` | `runtime-serializer.ts` (JSON) |
| `gen/.../event-codegen.ts` | Event data in JSON (scenes DDL) |
| `main/server/maps/tmx/*.tmx` | `data/maps/*.json` |
| `main/server/maps/events/*-events.ts` | ECS entity spawning from JSON |

### What Stays

| Directory | Why |
|-----------|-----|
| `gen/assemblage/` (most of it) | Still produces the instruction sets |
| `gen/ddl/` | Source of truth for game content |
| `gen/schemas/` | Validation stays |
| `docs/` | Source of truth for everything |
| `assets/tilesets/` | Skia loads these directly |

---

## Migration Phases

### Phase 1: Expo Scaffold + Tile Rendering

1. Create Expo app with Skia + Reanimated + expo-router
2. Build `runtime-serializer.ts` in gen/ (JSON output)
3. Load Everwick JSON in the app
4. Render tiles via Skia Atlas
5. Player movement + collision + camera
6. Prove: one map renders and is playable

### Phase 2: ECS + NPCs + Dialogue

1. Set up Miniplex world with entity types
2. Load NPCs/objects from JSON as entities
3. Interaction system (face NPC, press action)
4. Dialogue box UI component (React Native Reusables)
5. Vibrancy shader + particle system
6. Prove: walk around Everwick, talk to Artun, see vibrancy effects

### Phase 3: Multi-Map + Combat

1. Zone transitions (Everwick -> Heartfield -> Ambergrove)
2. Random encounter system
3. Combat UI (turn-based, resonance broadcast)
4. HUD (HP, vibrancy, minimap)
5. Prove: play through Act 1 Scene 1-6

### Phase 4: Full Act 1 + Polish

1. All 5 Settled Lands maps
2. Shop/Inn interiors (interior map loading)
3. Inventory + equipment
4. Quest log
5. Save/load (AsyncStorage)
6. Audio (BGM per zone, SFX for interactions)
7. Prove: complete Act 1 playthrough

### Phase 5: Delete RPG-JS

1. Remove all `@rpgjs/*` packages
2. Delete `main/` directory
3. Delete `rpg.toml`
4. Update CI/CD for Expo build
5. Update CLAUDE.md

---

## Success Criteria

- [ ] Everwick renders from JSON (not TMX) at 60fps
- [ ] Player walks with collision detection
- [ ] NPCs are interactable with dialogue
- [ ] Vibrancy shader transitions greyscale to color
- [ ] Zone transitions work without loading screens
- [ ] Combat system functions (turn-based, resonance broadcast)
- [ ] All Act 1 scenes playable
- [ ] Web deployment works via Expo web
- [ ] RPG-JS fully removed
- [ ] Game bundle is smaller than current RPG-JS build
- [ ] The game FEELS like memory awakening -- not a wireframe prototype
