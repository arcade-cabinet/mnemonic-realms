{
  "name": "MnemonicEngine — Custom Game Engine",
  "branchName": "ralph/mnemonic-engine",
  "description": "Replace RPG-JS with Expo + React Native Skia + Koota ECS custom game engine. Render onion system directly, seamless world transitions, spatial fog-of-war vibrancy, encounters world pattern, DDL-driven everything.",
  "userStories": [
    {
      "id": "US-001",
      "title": "Archive RPG-JS and scaffold Expo project",
      "description": "As a developer, I want the RPG-JS codebase archived (not deleted) and a clean Expo project scaffolded so that the new engine has a home while preserving all legacy context.",
      "acceptanceCriteria": [
        "main/ moved to docs/rpgjs-archive/main/",
        "rpg.toml moved to docs/rpgjs-archive/",
        "All @rpgjs/* packages removed from package.json dependencies",
        "Metro bundler config excludes docs/rpgjs-archive/",
        "Biome config excludes docs/rpgjs-archive/",
        "TypeScript config excludes docs/rpgjs-archive/",
        "Expo app scaffolded: app.json, app/_layout.tsx, app/index.tsx, app/game.tsx",
        "Expo dependencies installed: expo, @shopify/react-native-skia, react-native-reanimated, expo-router, react-native-gesture-handler, nativewind, koota",
        "pnpm expo start --web launches without errors (blank screen is fine)",
        "pnpm lint passes (archive excluded)",
        "Tests: scaffold test verifying Expo app mounts",
        "pnpm test:unit passes",
        "tsc --noEmit passes"
      ],
      "priority": 1,
      "passes": false,
      "notes": "",
      "dependsOn": []
    },
    {
      "id": "US-002",
      "title": "Koota ECS world + entity trait system",
      "description": "As a developer, I want a Koota ECS world with data-oriented SoA storage so that all game objects can be modeled as entities with typed traits, enabling deterministic rendering from instruction sets.",
      "acceptanceCriteria": [
        "engine/ecs/world.ts exports createGameWorld() using Koota createWorld()",
        "engine/ecs/traits.ts defines all traits: Position, Sprite, Facing, Velocity, Player, Npc, Collidable, Interactable, Dialogue, AiState, PatrolPath, Health, Inventory, QuestFlags, AreaVibrancy, Chest, ResonanceStone, Transition, Trigger",
        "Traits use Koota SoA storage for cache-friendly iteration",
        "engine/ecs/queries.ts exports pre-built queries using Koota query API",
        "Deterministic iteration order for rendering (Koota guarantees insertion-order queries)",
        "Unit tests: create world, add entities with traits, query by trait composition, verify counts",
        "Unit tests: entity lifecycle — add, remove, query updates reflect changes",
        "Unit tests: deterministic iteration order preserved across add/remove cycles",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 2,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-001"]
    },
    {
      "id": "US-003",
      "title": "Runtime JSON serializer + CLI emit-runtime",
      "description": "As a developer, I want the gen/ pipeline to output runtime JSON (not TMX) so that the new engine can load maps directly from the onion system's instruction sets.",
      "acceptanceCriteria": [
        "gen/assemblage/pipeline/runtime-serializer.ts exports serializeToRuntime(canvas: MapCanvas): RuntimeMapData",
        "gen/assemblage/pipeline/runtime-types.ts defines RuntimeMapData interface",
        "Runtime JSON preserves: semantic tile references, layer order, collision grid, visual objects, event objects, hooks, area vibrancy state (forgotten/partial/remembered)",
        "CLI command: pnpm assemblage emit-runtime [regionId|all] writes JSON to data/maps/",
        "pnpm assemblage emit-runtime settled-lands produces valid data/maps/settled-lands.json",
        "Unit tests: serialize simple canvas, verify structure",
        "Unit tests: round-trip — serialize then validate all fields present",
        "Integration test: emit-runtime for settled-lands, parse output, verify width/height/layers/objects",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 2,
      "passes": false,
      "notes": "Independent from Expo scaffold — works on existing gen/ pipeline",
      "dependsOn": []
    },
    {
      "id": "US-004",
      "title": "Map loader — JSON to ECS world",
      "description": "As a developer, I want a map loader that reads runtime JSON and populates the Koota ECS world so that tile data becomes typed arrays and behavioral objects become entities with traits.",
      "acceptanceCriteria": [
        "engine/world/loader.ts exports loadMapData(json: RuntimeMapData): LoadedMap",
        "LoadedMap contains: tile layers as typed arrays (NOT entities), collision as Uint8Array, entity descriptors for NPCs/chests/stones/transitions/triggers",
        "Tile data stays as flat arrays for performance (3600+ tiles per map)",
        "Only behavioral objects (20-50 per map) become Koota entity descriptors with traits",
        "engine/world/spawner.ts exports spawnEntities(world, entities) to create entities with appropriate traits",
        "Unit tests: load minimal JSON, verify tile arrays and entity counts",
        "Unit tests: verify entity descriptors have correct trait compositions",
        "Integration test: load settled-lands.json, spawn into world, query NPCs by trait",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 3,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-002", "US-003"]
    },
    {
      "id": "US-005",
      "title": "Skia tile renderer with viewport culling",
      "description": "As a player, I want to see the game world rendered as pixel-perfect 16x16 tiles so that the world looks intentional and authored, not blurry or stretched.",
      "acceptanceCriteria": [
        "engine/renderer/tile-renderer.tsx renders tile layers using Skia Atlas component",
        "FilterMode.Nearest for pixel-perfect rendering (no anti-aliasing on 16x16 tiles)",
        "Viewport culling: only tiles within camera bounds generate draw calls",
        "Multiple layers stack correctly: ground -> road -> water -> objects -> above",
        "Tile rendering logic lives in engine/renderer/, NOT in the component TSX",
        "Unit tests: viewport culling math — given camera bounds, correct tile subset selected",
        "Integration test: render a 4x4 test map, verify Atlas receives correct sprite rects",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 4,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-004"]
    },
    {
      "id": "US-006",
      "title": "Camera system with smooth following",
      "description": "As a player, I want the camera to smoothly follow my character so that movement feels natural and the world scrolls fluidly.",
      "acceptanceCriteria": [
        "engine/renderer/camera.tsx wraps renderers in Skia Group with translate transform",
        "Camera follows player entity position using Reanimated shared values",
        "Smooth interpolation (not instant snap) using spring or lerp",
        "Camera clamps to map bounds (doesn't show void beyond edges)",
        "Camera logic is a pure function in engine/ecs/systems/camera.ts, component only reads values",
        "Unit tests: camera system computes correct position from player position",
        "Unit tests: camera clamps at map boundaries",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 5,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-005"]
    },
    {
      "id": "US-007",
      "title": "Player movement + collision",
      "description": "As a player, I want to move my character with arrow keys/WASD and be blocked by walls so that I can explore the world and it feels solid.",
      "acceptanceCriteria": [
        "engine/ecs/systems/movement.ts — pure function, updates Position trait from Velocity trait",
        "engine/ecs/systems/collision.ts — pure function, checks collision grid before allowing movement",
        "engine/input.ts — maps keyboard (WASD/arrows) to velocity shared values",
        "engine/game-loop.ts — useFrameCallback ticks all systems at 60fps",
        "Grid-based movement: player moves tile-to-tile, not free-form",
        "Movement blocked by collision grid value 1",
        "Movement system is a pure function taking (world, dt), no side effects",
        "Unit tests: movement updates position correctly",
        "Unit tests: collision blocks movement into blocked tiles",
        "Unit tests: collision allows movement into clear tiles",
        "E2E test (Playwright): player renders on screen, arrow key moves player",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 6,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-002", "US-006"]
    },
    {
      "id": "US-008",
      "title": "NPC entities + interaction system",
      "description": "As a player, I want to walk up to NPCs and press action to talk to them so that the world feels inhabited and I can advance quests.",
      "acceptanceCriteria": [
        "engine/ecs/systems/interaction.ts — finds entity with Interactable trait in the tile the player faces",
        "engine/ecs/systems/npc-ai.ts — simple patrol/idle state machine using AiState + PatrolPath traits",
        "engine/renderer/sprite-renderer.tsx — Skia Atlas for entity sprites (player + NPCs)",
        "Action key (Space/Enter/Z) triggers interaction with faced entity",
        "Interaction returns the entity Dialogue/Chest/ResonanceStone trait data for UI to handle",
        "Sprite renderer logic in engine/renderer/, only markup in component",
        "Unit tests: interaction finds NPC in facing direction",
        "Unit tests: interaction returns null when facing empty tile",
        "Unit tests: NPC AI patrol follows path points",
        "Unit tests: NPC AI idle stays in place",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 7,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-007"]
    },
    {
      "id": "US-009",
      "title": "Gluestack UI theme + NativeWind setup",
      "description": "As a player, I want the game UI to feel like the game world — warm and authored — with a proper theme foundation for all UI components.",
      "acceptanceCriteria": [
        "ui/theme/game-theme.ts — theme tokens (colors, radii, shadows) with warm amber palette",
        "NativeWind (Tailwind for RN) configured with custom game color palette",
        "Gluestack UI installed and configured with context-based theme provider",
        "All UI components will use theme tokens, never hardcoded colors",
        "Unit tests: theme function returns correct color tokens",
        "Integration test: theme provider wraps app, components receive correct tokens",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 3,
      "passes": false,
      "notes": "Can run in parallel with ECS work since it only depends on Expo scaffold",
      "dependsOn": ["US-001"]
    },
    {
      "id": "US-010",
      "title": "Dialogue box UI component",
      "description": "As a player, I want dialogue to appear in a beautiful bottom panel with character portraits and typewriter text so that conversations feel authored and immersive.",
      "acceptanceCriteria": [
        "ui/dialogue-box.tsx — React Native component (NOT Skia), overlays game canvas",
        "ui/hooks/use-typewriter.ts — hook for letter-by-letter text reveal with complete() function",
        "Character portrait on left (animated idle)",
        "Speaker name in accent color",
        "Text materializes with subtle opacity (not harsh typewriter)",
        "Frosted glass background",
        "Choice options slide in from right when dialogue has choices",
        "Advance indicator pulses gently at bottom-right",
        "All dialogue logic in hooks/utilities, component is pure rendering",
        "Unit tests: useTypewriter reveals text, complete() finishes instantly",
        "Unit tests: useTypewriter tracks isComplete state",
        "Integration test: dialogue component renders with portrait + text + choices",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 8,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-001", "US-009"]
    },
    {
      "id": "US-011",
      "title": "Vibrancy fog-of-war — area state system",
      "description": "As a developer, I want a per-area vibrancy state system that tracks which areas are forgotten/partial/remembered based on quest progression, so that the fog-of-war can be driven by game data.",
      "acceptanceCriteria": [
        "engine/ecs/systems/vibrancy.ts — computes per-area vibrancy state from quest progression flags",
        "Three states per area: Forgotten (opaque darkness), Partial (colored haze), Remembered (crystal clear)",
        "Player current area and all fully-remembered areas are always crystal clear",
        "Forgotten areas: player can enter a few paces, then gets warned and starts taking damage",
        "Quest progression gradually unlocks areas: forgotten -> partial -> remembered",
        "Vibrancy state per area stored in save-compatible format",
        "Unit tests: vibrancy system computes area state from quest flags",
        "Unit tests: damage-on-entry for forgotten areas triggers correctly",
        "Unit tests: quest completion transitions area from forgotten -> partial -> remembered",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 9,
      "passes": false,
      "notes": "Pure logic — no rendering. The shader comes in US-012.",
      "dependsOn": ["US-002"]
    },
    {
      "id": "US-012",
      "title": "Vibrancy fog-of-war — SkSL shader + renderer",
      "description": "As a player, I want forgotten areas shrouded in darkness and partially remembered areas glowing through colored haze, so that the world visually reflects my journey without degrading gorgeous pixel art in active areas.",
      "acceptanceCriteria": [
        "engine/renderer/shader/fog-of-war.ts — SkSL shader that applies darkness/haze per-area based on vibrancy map",
        "Applied via RuntimeShader over game canvas Group",
        "Forgotten areas: opaque black fog (art not visible)",
        "Partial areas: colored haze — shapes visible through the haze as an invitation",
        "Remembered areas: crystal clear, no filter, full gorgeous pixel art",
        "Vibrancy map uniform passed as Reanimated shared value (smooth transitions when areas unlock)",
        "The 16-bit art is ALWAYS visible and beautiful in remembered areas — no filter, no tinting",
        "Integration test: shader compiles without errors in Skia runtime",
        "Integration test: different visual states rendered for different area vibrancy levels",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 10,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-005", "US-011"]
    },
    {
      "id": "US-013",
      "title": "HUD — vibrancy meter, zone placard, HP bar",
      "description": "As a player, I want a minimal HUD showing my health, the current zone name, and a subtle vibrancy indicator so that I always know where I am.",
      "acceptanceCriteria": [
        "ui/hud.tsx — container component, React Native overlay",
        "ui/hud/zone-placard.tsx — zone name drifts in on entry, holds 3s, dissolves",
        "ui/hud/hp-bar.tsx — red gradient, current/max",
        "ui/hud/vibrancy-meter.tsx — subtle indicator showing area memory state",
        "HUD fades to near-invisible during exploration, brightens during key moments",
        "All display logic in pure functions, not in component TSX",
        "Unit tests: zone placard timing logic (show, hold, dissolve)",
        "Integration test: HUD renders with all sub-components",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 11,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-009", "US-012"]
    },
    {
      "id": "US-014",
      "title": "Memory mote particle system",
      "description": "As a player, I want ambient particles (memory motes) drifting through the world so that the atmosphere feels alive with different character per area state.",
      "acceptanceCriteria": [
        "engine/ecs/systems/particles.ts — manages particle pool as typed arrays (NOT entities)",
        "engine/renderer/particle-renderer.tsx — Skia Atlas for mote sprites",
        "Mote character varies by area state: ghostly wisps in partial areas, golden sparkles in remembered, absent in forgotten",
        "Motes drift with random velocity, fade over lifetime",
        "Expired particles recycled, not garbage collected",
        "Particle logic is pure functions in engine/ecs/systems/, renderer only reads state",
        "Unit tests: spawnMotes produces correct mote types per area state",
        "Unit tests: updateParticles removes expired, moves active",
        "Unit tests: particle pool size stays bounded",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 11,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-012"]
    },
    {
      "id": "US-015",
      "title": "World transition system — seamless zone changes",
      "description": "As a player, I want to walk from Everwick to Heartfield without loading screens so that the world feels connected and real.",
      "acceptanceCriteria": [
        "engine/world/transition.ts — manages seamless zone transitions",
        "Walking to transition tile triggers: load adjacent JSON, cross-fade, swap tile data, spawn new entities, show zone placard",
        "No loading screens, no black frames",
        "Camera pans smoothly during transition",
        "Old zone entities removed, new zone entities spawned",
        "Transition system is pure function in engine/world/, renderer reacts to state changes",
        "Works for: overworld-to-overworld, overworld-to-child-world (shops/inns), child-world-to-overworld, overworld-to-encounters-world",
        "Unit tests: transition state machine (idle -> loading -> crossfade -> complete)",
        "Integration test: load two maps, trigger transition, verify entity swap",
        "E2E test: player walks to zone edge, transition occurs, new zone renders",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 12,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-004", "US-006", "US-013"]
    },
    {
      "id": "US-016",
      "title": "Encounters world — DDL schema + serializer",
      "description": "As a developer, I want a DDL schema for encounters so that combat, special dialogue, and story moments are data-driven in the onion hierarchy — regions are encounter classes, locations are specific encounters.",
      "acceptanceCriteria": [
        "gen/schemas/ddl-encounters.ts — Zod schema for encounter definitions",
        "Schema defines: encounter layout, enemy positions, background, music, dialogue hooks, chain-to references",
        "Regions = encounter classes (e.g., settled-lands-wildlife, frontier-elementals)",
        "Locations = specific encounters within a class (e.g., wolf-pack, slime-swarm)",
        "Chaining support: beat-this -> go-to-this, talk-to-this -> surprise -> beat-this",
        "gen/assemblage/pipeline/runtime-serializer.ts extended to emit encounter JSON",
        "gen/ddl/encounters/ directory with sample encounter definitions",
        "Overworld regions can specify default random encounter pools from encounter classes",
        "Unit tests: encounter DDL validates correctly against Zod schema",
        "Unit tests: encounter chain resolution — given chain spec, correct sequence produced",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 8,
      "passes": false,
      "notes": "DDL schema work — independent from rendering. Can run in parallel with UI stories.",
      "dependsOn": ["US-003"]
    },
    {
      "id": "US-017",
      "title": "Encounters world — combat engine + split-screen UI",
      "description": "As a player, I want Final Fantasy / Chrono Trigger style split-screen combat with class skills, weapon masteries, items, and defense options.",
      "acceptanceCriteria": [
        "engine/encounters/ subpackage — encounter world system",
        "ui/combat-ui.tsx — split-screen layout: enemies top, player commands bottom",
        "Player commands: Attack, Broadcast (Resonance), Item, Defend, Flee",
        "Class skills and weapon masteries selectable from command menu",
        "Resonance broadcast: radial selector for emotion (joy/sorrow/fury/calm/awe) + element (fire/water/earth/wind/light) + potency (1-5)",
        "Turn order display showing upcoming turns",
        "Combat logic in engine/encounters/: turn order, damage calc, status effects",
        "Unit tests: damage calculation with type effectiveness",
        "Unit tests: turn order determination",
        "Unit tests: resonance broadcast applies correct effects",
        "E2E test: enter combat, select attack, enemy takes damage",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 13,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-010", "US-015", "US-016"]
    },
    {
      "id": "US-018",
      "title": "Encounters world — chaining + special encounters",
      "description": "As a player, I want encounters to chain together — combat to dialogue to surprise to combat — so that special story moments play out as scripted encounter sequences.",
      "acceptanceCriteria": [
        "engine/encounters/chain.ts — manages encounter chain execution",
        "Special encounters support dialogue exchange within the encounter (NPC talks mid-fight, story moments)",
        "Chaining: beat this -> go to this, talk to this -> talk to this, surprise twist -> fight this",
        "Random encounter pools per overworld region (configurable in region DDL)",
        "Transition TO/FROM encounters world uses same transition system as shops/dungeons (US-015)",
        "Anchors between overworld locations and encounter world locations",
        "Unit tests: encounter chain executes steps in correct order",
        "Unit tests: random encounter pool selection respects region config",
        "Integration test: transition to encounter, execute combat round, chain to dialogue, transition back",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 14,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-017"]
    },
    {
      "id": "US-019",
      "title": "Touch input + mobile controls",
      "description": "As a mobile player, I want touch controls (virtual d-pad) so that the game is playable on phones and tablets without a keyboard.",
      "acceptanceCriteria": [
        "engine/input.ts extended with touch input via react-native-gesture-handler",
        "Virtual d-pad overlay on mobile (semi-transparent, bottom-left)",
        "Action button (bottom-right) for interaction/confirm",
        "Input handler is platform-agnostic — keyboard on web, touch on mobile",
        "Input logic decoupled from rendering — produces velocity/action shared values consumed by systems",
        "Unit tests: keyboard handler maps keys to velocity",
        "Unit tests: touch handler maps gestures to velocity",
        "E2E test: touch d-pad visible on mobile viewport size",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 9,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-007"]
    },
    {
      "id": "US-020",
      "title": "Inventory + equipment + shop screens",
      "description": "As a player, I want to manage my items, equip gear, and buy from shops so that character progression feels tangible and shopkeepers have personality.",
      "acceptanceCriteria": [
        "ui/inventory-screen.tsx — parchment grid, equipment silhouette, resonance fragments as orbiting gems",
        "ui/shop-screen.tsx — buy/sell with keeper personality quotes (from dialogue DDL)",
        "Drag-to-equip with spring animations (Moti)",
        "Item detail: name, in-world description, then stats",
        "Shop prices, inventory management in engine/inventory/ subpackage",
        "Unit tests: add/remove items, equip/unequip, gold calculations",
        "Unit tests: shop buy/sell transactions",
        "Integration test: inventory screen renders items from player entity",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 13,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-010", "US-009"]
    },
    {
      "id": "US-021",
      "title": "Audio system — BGM + SFX with area vibrancy response",
      "description": "As a player, I want background music per zone and sound effects for interactions, with area memory state affecting audio mood via low-pass filter.",
      "acceptanceCriteria": [
        "engine/audio/music.ts — BGM management using expo-audio",
        "engine/audio/sfx.ts — SFX playback (dialogue blip, chest open, resonance hum)",
        "BGM crossfades on zone transitions (not hard cut)",
        "Audio responds to area memory state via BiquadFilterNode low-pass sweep: forgotten = 2000Hz cutoff (muffled), remembered = 20000Hz cutoff (full clarity)",
        "SFX for: dialogue advance, choice select, chest open, stone discover, combat hit, menu navigate",
        "Audio logic in engine/audio/ subpackage, components trigger via events",
        "Unit tests: audio state machine (idle -> playing -> crossfading -> playing)",
        "Integration test: zone transition triggers BGM crossfade",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 10,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-001"]
    },
    {
      "id": "US-022",
      "title": "Quest log + save/load",
      "description": "As a player, I want to track active quests and save my progress (including area vibrancy states) so that I can play in sessions and always know what to do next.",
      "acceptanceCriteria": [
        "ui/quest-log.tsx — styled as Callum's journal, not a database table",
        "Active quests with current objective highlighted",
        "Completed quests accessible but visually distinct",
        "engine/save/ subpackage — serializes player entity + quest flags + discovered stones + area vibrancy states",
        "Save to AsyncStorage (web: localStorage)",
        "Load restores exact game state: position, inventory, quests, area vibrancy states",
        "Title screen: New Journey / Continue options",
        "Unit tests: save serialization round-trips correctly",
        "Unit tests: quest state tracking (start, advance, complete)",
        "E2E test: save game, reload page, continue from save",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 14,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-010", "US-009"]
    },
    {
      "id": "US-023",
      "title": "Title screen with class selection",
      "description": "As a player, I want a beautiful title screen where I choose my class and start a new journey so that the first impression sets the tone for the entire game.",
      "acceptanceCriteria": [
        "ui/title-screen.tsx — game logo emerges from soft haze to golden clarity",
        "Mnemonic Realms appears letter-by-letter with memory mote particles",
        "Menu: New Journey / Continue / Settings",
        "Class selection: three archetypes with idle animations and personality quotes",
        "Spring-based animations throughout (Moti)",
        "E2E test: title screen renders, class selection works, game starts",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 15,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-012", "US-009"]
    },
    {
      "id": "US-024",
      "title": "Expo web build + PWA deployment",
      "description": "As a developer, I want pnpm build:web to produce a deployable PWA with lazy asset loading so that the game can be hosted on GitHub Pages.",
      "acceptanceCriteria": [
        "pnpm build:web runs expo export --platform web successfully",
        "Output directory is dist/ (matching current CI)",
        "All game assets (tileset PNGs, runtime JSON, sprites) bundled correctly",
        "PWA configuration for offline caching and lazy asset loading",
        "GitHub Actions CI updated: install -> lint -> test -> build:web -> deploy",
        "Game loads in browser from deployed build",
        "E2E test (Playwright): navigate to built game, verify title screen renders",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 3,
      "passes": false,
      "notes": "Can be done early — just needs Expo scaffold working",
      "dependsOn": ["US-001"]
    },
    {
      "id": "US-025",
      "title": "Full content generation — all maps + encounters to runtime JSON",
      "description": "As a developer, I want all 20+ maps and all encounter definitions generated as runtime JSON so that the entire game world is loadable by the new engine.",
      "acceptanceCriteria": [
        "pnpm assemblage emit-runtime all generates JSON for all regions",
        "Settled Lands (5 maps): Everwick, Heartfield, Ambergrove, Millbrook, Sunridge",
        "Frontier (4 maps): Shimmer Marsh, Hollow Ridge, Flickerveil, Resonance Fields",
        "Sketch Realm (3 maps): Luminous Wastes, Undrawn Peaks, Half-Drawn Forest",
        "Depths (5 maps): L1 through L5",
        "Fortress (3 maps): F1 through F3",
        "All child world maps (shops, inns, residences)",
        "Encounters world: all encounter class regions + specific encounter locations",
        "Each JSON validated against RuntimeMapData / RuntimeEncounterData schemas",
        "Integration test: load every generated JSON, verify structure",
        "pnpm test:unit passes",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 16,
      "passes": false,
      "notes": "",
      "dependsOn": ["US-003", "US-016"]
    },
    {
      "id": "US-026",
      "title": "CLAUDE.md + documentation update",
      "description": "As a developer, I want CLAUDE.md and project docs updated to reflect the new engine architecture so that future development sessions have correct context.",
      "acceptanceCriteria": [
        "CLAUDE.md updated: remove all RPG-JS references from active sections",
        "CLAUDE.md updated: new Architecture section for MnemonicEngine (Koota ECS, Skia renderer, encounters world, fog-of-war vibrancy)",
        "CLAUDE.md updated: new Commands section (expo start, build:web, etc.)",
        "CLAUDE.md updated: archive reference pointing to docs/rpgjs-archive/",
        "README.md updated with new setup instructions",
        "All references to main/ directory updated to engine/ + app/ + ui/",
        "pnpm lint passes",
        "tsc --noEmit passes"
      ],
      "priority": 3,
      "passes": false,
      "notes": "Can be done early, right after archiving RPG-JS",
      "dependsOn": ["US-001"]
    }
  ]
}
